# 포지션 사이징 (Position Sizing)

## 현재 방식: 올인/올아웃

```
signal = 1  →  100% 레버리지 (3x)
signal = 0  →  100% 현금 (T-Bill)
```

장점: 단순, 거래 횟수 최소, 시그널이 맞으면 최대 수익.
단점: 시그널이 틀리면 최대 손실, 위플래시에서 큰 비용.

---

## 대안 1: 변동성 역비례 사이징

### 아이디어
변동성이 높으면 레버리지를 줄이고, 낮으면 늘린다. "위험할 때 작게 배팅, 안전할 때 크게 배팅."

### 공식
```
effective_leverage = base_leverage × (target_vol / realized_vol)
                   = 3.0 × (15% / current_ann_vol)

예시:
  현재 vol = 10% → leverage = 3.0 × 15/10 = 4.5 → cap at 3.0
  현재 vol = 20% → leverage = 3.0 × 15/20 = 2.25
  현재 vol = 40% → leverage = 3.0 × 15/40 = 1.13
```

### 장단점
- **장점**: MDD 축소 (고변동 시기에 자동으로 축소), 변동성 클러스터링 활용
- **단점**: 급등장에서도 축소 (COVID 반등 시 vol이 아직 높음 → 레버리지 낮음), 매일 리밸런싱 필요 → 거래비용

---

## 대안 2: 레짐 기반 사이징

### 아이디어
현재 레짐에 따라 레버리지를 단계적으로 조절. 올인/올아웃의 "중간" 옵션.

### 단계
```
평시 (signal=1, vol 낮음)       → 3x (풀 레버리지)
경계 (signal=1, vol 중간)       → 2x (부분 레버리지)
위기 (signal=1, vol 높음)       → 1x (레버리지 없음, 그냥 주식)
탈출 (signal=0)                → 0x (현금)
```

### 장단점
- **장점**: 직관적, 거래 빈도 적당, "다 맞거나 다 틀리지 않음"
- **단점**: 레짐 경계값 설정이 자의적, 3단계 사이 전환 시 위플래시 가능

---

## 대안 3: 연속 사이징

### 아이디어
시그널을 0/1 이진값이 아닌 연속값(0.0 ~ 1.0)으로 만들어 레버리지를 비례 적용.

### 공식
```
# MA 거리 기반 확신도
confidence = (fast_ma - slow_ma) / slow_ma  # 양수면 매수 우위
confidence = clip(confidence, 0, 1)

effective_leverage = base_leverage × confidence
```

또는 변동성 결합:
```
leverage = base_leverage × confidence × (1 - risk_scaling × vol_ratio)
```

### 장단점
- **장점**: 매끄러운 전환 (위플래시 비용 감소), 확신도 반영
- **단점**: 매일 리밸런싱 → 거래비용 급증, 복잡도 증가, "중간" 포지션에서 성과 하락

---

## 대안 4: 켈리 기준 (Kelly Criterion)

### 아이디어
기대수익/분산 비율로 최적 베팅 크기를 수학적으로 계산.

### 공식
```
f* = (μ - r) / σ²

μ = 레버리지 전략의 기대 일간 수익률
r = 무위험 수익률
σ² = 수익률 분산

예시:
  μ = 0.08% (일간), r = 0.02% (일간), σ² = 0.0004
  f* = (0.0008 - 0.0002) / 0.0004 = 1.5 (150%)
```

### 장단점
- **장점**: 이론적 최적 (기하 성장률 최대화), 수학적 근거
- **단점**: 추정 오류에 극히 민감 (μ가 0.01% 틀려도 결과 크게 변함), 풀 켈리는 MDD가 극심 → 실무에서는 Half-Kelly 사용, 분포 가정(정규분포)이 틀림 (fat tail)

---

## 올인/올아웃 vs 연속 사이징: 핵심 트레이드오프

| 측면 | 올인/올아웃 | 연속 사이징 |
|------|-----------|------------|
| 거래 빈도 | 연 5-10회 | 매일 리밸런싱 |
| 거래비용 (0.2% comm) | 연 1-2% | 연 50%+ (불가) |
| 시그널이 맞을 때 | 최대 수익 | 수익 축소 |
| 시그널이 틀릴 때 | 최대 손실 | 손실 축소 |
| MDD | 크다 | 작다 |
| 복잡도 | 낮음 | 높음 |
| 심리적 부담 | 올인/올아웃 스트레스 | "중간"의 편안함 |

**핵심**: 연속 사이징은 "틀려도 덜 아프다" 대신 "맞아도 덜 번다." 0.2% 거래비용이 있는 우리 프레임워크에서는 **매일 리밸런싱하는 연속 사이징은 비현실적**.

---

## 현실적 추천: 2단계 사이징

위 분석을 종합하면, 우리 프레임워크에 가장 적합한 방식:

```
signal = 1 + vol 낮음  →  3x (현행 유지)
signal = 1 + vol 높음  →  2x (레버리지 축소)
signal = 0             →  현금 (현행 유지)
```

이유:
1. 거래 빈도 증가 최소 (레짐 전환은 연 2-4회 추가)
2. 고변동 시 MDD 축소 효과
3. 기존 프레임워크에서 쉽게 구현 가능
4. 올인/올아웃의 단순성 유지

---

## 프레임워크 구현 방향

### `run_lrs()` 수정

현재:
```python
def run_lrs(price, signal, leverage=2.0, ...):
    # leverage는 스칼라 → 모든 날 동일
```

수정:
```python
def run_lrs(price, signal, leverage=2.0, ...):
    # leverage가 스칼라면 현행 동작
    # leverage가 pd.Series면 날짜별 다른 레버리지 적용
    if isinstance(leverage, pd.Series):
        daily_lev = leverage.reindex(price.index).ffill()
    else:
        daily_lev = leverage
```

### 시그널 확장

현재 시그널: `pd.Series` (0 또는 1)

확장: 연속값 사이징을 위해 시그널이 0.0 ~ 1.0 사이 값을 가질 수 있도록:
```python
# signal=0.7이면 leverage = 3.0 × 0.7 = 2.1x 적용
effective_leverage = base_leverage * signal
```

### 주의사항

- 연속 사이징 시 `signal_trades_per_year()` 메트릭이 의미 없어짐 (매일 "거래")
- 거래비용 모델도 수정 필요 (현재: 시그널 flip마다 고정 비용 → 포지션 변화량 비례 비용으로)
- 이러한 수정은 기존 백테스트 결과에 영향을 주지 않아야 함 (하위 호환성)

---

## 결론

포지션 사이징은 이론적으로 매력적이지만, **0.2% 거래비용이 있는 레버리지 전략에서는 올인/올아웃이 실질적으로 최적에 가깝다.** 리밸런싱 빈도를 대폭 늘리면 거래비용이 수익을 잠식.

개선 여지가 있다면 **2단계 사이징** (고변동 시 레버리지만 줄이기)이 가장 현실적인 방안이며, 이는 매크로 레짐 시그널과 자연스럽게 결합된다.
